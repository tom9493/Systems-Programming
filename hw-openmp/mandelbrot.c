/*
  This program is an adaptation of the Mandelbrot program
  from the Programming Rosetta Stone, see
  http://rosettacode.org/wiki/Mandelbrot_set

  Compile the program with:

  gcc -o mandelbrot -O4 mandelbrot.c

  Usage:
 
  ./mandelbrot <xmin> <xmax> <ymin> <ymax> <maxiter> <xres> <out.ppm>

  Example:

  ./mandelbrot 0.27085 0.27100 0.004640 0.004810 1000 1024 pic.ppm

  The interior of Mandelbrot set is black, the levels are gray.
  If you have very many levels, the picture is likely going to be quite
  dark. You can postprocess it to fix the palette. For instance,
  with ImageMagick you can do (assuming the picture was saved to pic.ppm):

  convert -normalize pic.ppm pic.png

  The resulting pic.png is still gray, but the levels will be nicer. You
  can also add colors, for instance:

  convert -negate -normalize -fill blue -tint 100 pic.ppm pic.png

  See http://www.imagemagick.org/Usage/color_mods/ for what ImageMagick
  can do. It can do a lot.


  1 core: 
  	parallel region: 29.480119
	enitre program: 35.12
  2 cores:
  	parallel region: 15.715529
	entire program: 21.78
  4 cores:
  	parallel region: 8.859748
	entire program: 14.98
  8 cores:
  	parallel region: 4.937784
	entire program: 11.01
  16 cores:
  	parallel region: 3.398531
	entire program: 9.46
  32 cores:
  	parallel region: 2.509127
	entire program: 8.53

1) 20 cores
2) The time gets cut in half approximately. The time difference gets less drastic when the cores continue to rise.
3) 29.480119 original time / 20.620371 second time, so speedup = 1.4297
4) 16 threads
5) The cores have to communcate with each other, so using more of them requires more computation and decreases the speedup
6) Original time: 35.12
   4 corses time: 14.98
   35.12/14.98 = 2.345
7) E = 1/P * speedup = 1/4 * 2.345 = 0.586
8) There are hardware limitations, so only a little over half of the threads contributed to the speedup
9) 14.98 = p(35.12)/1.4297 + (1-p)35.12
   Using a calculator, p = 1.908          
10) using a calculator, the elapsed time as alpha approaches infinity and p is set to 1.908: T_alpha = -31.89

Just to note, the answers to 9 and 10 don't make sense to me in the context of the problem, but i've quadruple checked the values in terms of the Amdahl's Law equation posted in the writeup. I also asked on slack if the values I was getting were correct for questions 3 (speedup) and 9 (fraction of parallelizable region) and nobody responded.   

*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdint.h>
#include <omp.h>

int main(int argc, char* argv[])
{
  /* Parse the command line arguments. */
  if (argc != 8) {
    printf("Usage:   %s <xmin> <xmax> <ymin> <ymax> <maxiter> <xres> <out.ppm>\n", argv[0]);
    printf("Example: %s 0.27085 0.27100 0.004640 0.004810 1000 1024 pic.ppm\n", argv[0]);
    exit(EXIT_FAILURE);
  }

  /* The window in the plane. */
  const double xmin = atof(argv[1]);
  const double xmax = atof(argv[2]);
  const double ymin = atof(argv[3]);
  const double ymax = atof(argv[4]);

  /* Maximum number of iterations, at most 65535. */
  const uint16_t maxiter = (unsigned short)atoi(argv[5]);

  /* Image size, width is given, height is computed. */
  const int xres = atoi(argv[6]);
  const int yres = (xres*(ymax-ymin))/(xmax-xmin);

  /* The output file name */
  const char* filename = argv[7];

  /* Open the file and write the header. */
  FILE * fp = fopen(filename,"wb");
  char *comment="# Mandelbrot set";/* comment should start with # */

  /*write ASCII header to the file*/
  fprintf(fp,
          "P6\n# Mandelbrot, xmin=%lf, xmax=%lf, ymin=%lf, ymax=%lf, maxiter=%d\n%d\n%d\n%d\n",
          xmin, xmax, ymin, ymax, maxiter, xres, yres, (maxiter < 256 ? 256 : maxiter));

  /* Precompute pixel width and height. */
  double dx=(xmax-xmin)/xres;
  double dy=(ymax-ymin)/yres;

  double x, y; /* Coordinates of the current point in the complex plane. */
  double u, v; /* Coordinates of the iterated point. */
  int i,j; /* Pixel counters */
  int k; /* Iteration counter */
  int *saved = malloc(sizeof(int)*yres*xres);

  double start = omp_get_wtime();

  #pragma omp parallel for private(k, y, x, i) firstprivate(saved)
  for (j = 0; j < yres; j++) {
    y = ymax - j * dy;
    for(i = 0; i < xres; i++) {
      double u = 0.0;
      double v= 0.0;
      double u2 = u * u;
      double v2 = v*v;
      x = xmin + i * dx;
      /* iterate the point */
      for (k = 1; k < maxiter && (u2 + v2 < 4.0); k++) {
            v = 2 * u * v + y;
            u = u2 - v2 + x;
            u2 = u * u;
            v2 = v * v;
      };
      saved[xres * j + i] = k;
    }
  }
  double end = omp_get_wtime();
  printf("%f seconds\n", end - start);
  fflush(stdout);

  for (j = 0; j < yres; j++) {
    for(i = 0; i < xres; i++) {
      /* compute  pixel color and write it to file */
      k = saved[xres * j + i];
      if (k >= maxiter) {
        /* interior */
        const unsigned char black[] = {0, 0, 0, 0, 0, 0};
        fwrite (black, 6, 1, fp);
      }
      else {
        /* exterior */
        unsigned char color[6];
        color[0] = k >> 8;
        color[1] = k & 255;
        color[2] = k >> 8;
        color[3] = k & 255;
        color[4] = k >> 8;
        color[5] = k & 255;
        fwrite(color, 6, 1, fp);
      };
    }
  }
  fclose(fp);
  free(saved);
  return 0;
}
